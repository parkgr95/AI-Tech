# 1. 2월 9일 (Day 15) 강의 정리

### (1강) 강의 소개

### (2강) 머신러닝 프로젝트 라이프 사이클

1. 머신러닝 프로젝트 Flow

   1.1 문제 정의의 중요성

   - 앞으로 겪을 일은 대부분 문제(**Problem**)로 정의할 수 있다.

   - 문제를 잘 풀기(Solve) 위해선 문제정의(Problem Definition)가 매우 중요하다.

     - 문제 정의 : 특정 현상을 파악하고, 그 현상에 있는 문제(Problem)을 정의하는 과정

   - 문제는 명확하지 않으면 무엇을 해야할지 결정하기 어려워진다.

   - 문제를 충분히 정의하고 고민하는 습관 만드는 것이 중요하다.

   - 머신러닝, AI, 데이터 사이언스, 개발 등 대부분 업무에서 항상 문제 정의가 선행되어야 한다.

   - How보다 **Why에 집중**

   - 문제 정의란?

     - 본질을 파악하는 과정
     - **해결해야 하는 문제는 무엇이고 그 문제를 해결하면 무엇이 좋을까? 어떻게 해결하면 좋을까?**

   - 프로젝트 Flow

     - 현상 파악

     - 목적, 문제 정의 => 계속 생각하기, 쪼개서 생각하기

     - 프로젝트 설계

     - Action

     - 추가 원인 분석

   1.2 현상 파악

   - 어떤 현상이 발견되었는가? 현재 상황을 파악한다.

   1.3 구체적인 문제 정의

   - **앞선 현상을 더 구체적으로 명확한 용어로 정리해보기**
   - 이 문제를 일으키는 원인, 해결방안 고민해보기
   - 룰 베이스 (추천) => 당장의 문제 해결
   - 추천 = 알고리즘 개발 => 문제 해결의 또 다른 방법
   - 문제 정의는 결국 현상을 계속 쪼개고, 그 문제를 기반으로 어떤 어려움을 겪고 있는지를 파악함
   - **데이터로 할 수 있는 일을 만들어서 진행하되, 무조건 알고리즘 접근이 최상은 아니라는 방법을 제시할 수도 있어야 함(간단한 방법부터 점진적인 접근) 우리는 시간의 제약을 받고 있기 때문!**
   - 인지하면 좋은 내용
     - 문제를 쪼개서 파악해보자
     - 문제의 해결 방식은 다양하다
     - 해결 방식 중에서 데이터로 해결할 수 있는 방법을 고민해보기
     - 점진적으로 실행하기

   1.4 프로젝트 설계

   - 실제 머신러닝 프로젝트 과정

     - 문제 정의

     - 최적화할 Metric 선택

     - 데이터 수집, 레이블 확인 - 제일 오래 걸리고 중요

     - 모델 개발 - 생각보다 어렵진 않음

     - 모델 예측 결과를 토대로 Error Analysis. 잘못된 라벨이 왜 생기는지 확인

     - 다시 모델 학습

     - 더 많은 데이터 수집

     - 다시 모델 학습

     - 2달 전 테스트 데이터에선 성능이 좋지만 어제 데이터엔 성능이 좋지 않음

     - 모델을 다시 학습함

     - 모델 배포

     - 최적화할 Metric이 실제로 잘 동작하지 않아 Metric을 수정

     - 다시 시작 ㅠ

   - 문제 정의 후, 프로젝트의 설계를 최대한 구체적으로 하는 것이 중요!
   - 문제 정의에 기반해서 프로젝트 설계
     - 머신러닝 문제 타당성 확인
       - 머신러닝 문제를 고려할 때는 **얼마나 흥미로운지가 아니라 제품, 회사의 비즈니스에 어떤 가치를 줄 수 있는지** 고려해야 한다.
       - 머신러닝 문제는 결국 데이터로부터 어떤 함수를 학습하는 것
       - 머신러닝 문제 타당성 평가하기 : 복잡도를 평가하는 방법은 필요한 데이터의 종류와 기존 모델이 있는지 살펴보기 (논문, sota 등)
       - 머신러닝은 모든 문제를 해결할 수 있는 마법의 도구가 아님. 또한, 머신러닝으로 해결할 수 있는 문제지만 머신러닝 솔루션이 최적이 아닐 수도 있음
       - 머신러닝이 사용되면 좋은 경우
         - **패턴 : 학습할 수 있는 패턴이 있는지**
         - **목적 함수 : 학습을 위한 목적 함수를 만들 수 있어야 함 (어떻게 정의해야 할 지)**
         - **복잡성 : 패턴이 복잡해야 함**
         - **데이터 존재 여부 : 데이터가 존재하거나 수집할 수 있어야 함**
         - **반복 : 사람이 반복적으로 실행하는 경우*
       - 머신러닝이 사용되면 좋지 않은 경우
         - 비윤리적인 문제
         - 간단히 해결할 수 있는 경우
         - 좋은 데이터를 얻기 어려울 경우
         - 한번의 예측 오류가 치명적인 결과를 발생할 경우
         - 시스템이 내리는 모든 결정이 설명 가능해야 할 경우
         - 비용 효율적이지 않은 경우

   1.5 지표 결정

   - 프로젝트의 목표
     - Goal : 프로젝트의 일반적인 목적, 큰 목적
     - Objectives : 목적을 달성하기 위한 세부 단계의 목표(구체적인 목적)
   - 목표를 설정하며 데이터를 확인해야 함(지표와 연결되는 내용이기 때문에)
     - 데이터셋이 레이블링이 되지 않은 경우도 존재
     - 데이터 소스 찾아보기
     - 정확히 찾으려는 데이터가 없는 경우가 있어서 여러가지 시나리오를 고려하는 것이 좋음
       - Label을 가진 데이터가 있는 경우 ⇒ 바로 사용
       - 유사 Label을 가진 데이터가 있는 경우 ⇒ 음악 스트리밍 서비스에서 노래 재생, 건너뛰기 기록은 선호도를 예측하기 위한 유사 Label
       - Label이 없는 데이터 ⇒ 직접 레이블링 or 레이블링이 없는 상태에서 학습하는 방법 찾기
       - 데이터가 아예 없는 경우 ⇒ 데이터 수집 방법부터 고민
       - 데이터셋을 만드는 일은 반복적인 작업 ⇒ 이걸 위해 Self Supervised Learning 등을 사용해서 유사 레이블을 만드는 방법도 존재
     - Multiple Objective Optimization
       - 최적화하고 싶은 목적 함수가 여러가지 있는 경우, 서로 충돌할 수 있음
       - Objective가 여러개인 경우 분리하는 것이 좋음
       - 학습하기 쉬워야 함
       - 모델을 재학습하지 않도록 모델을 분리
       - Objectives는 수정해야 하는 유지보수 일정이 모두 다를 수 있음
   - 제약 조건(Constraint & Risk)
     - 일정, 예산, 관련된 사람
     - Privacy : Storage, 외부 솔루션, 클라우드 서비스 등에 대한 개인정보 보호 요구
     - 기술적 제약 
       - 기존에 운영하고 있던 환경 : 레거시 환경(인프라)가 머신러닝 적용할 때 큰 제약일 수 있음
     -  윤리적 이슈 : 윤리적으로 어긋난 결과
     - 성능
       - Baseline : 새로 만든 모델을 무엇과 비교할 것인가? 기존에 사람이 진행하던 성능 or 간단한 회귀
       - Threshold : 확률값이 0.5 이상일 경우 강아지라고 할 것인지, 0.7 이상일 경우 강아지라고 할 것인지?
       - Performance Trade-off : 속도가 빠른데 Acc 0.95 vs 속도는 조금 더 느린데 Acc 0.93 
       - 해석 가능 여부 : 결과가 왜 발생했는지 해석이 필요할까? 해석이 필요한 사람은?
       - Confidence Measurement : False Negative가 있어도 괜찮은지? 오탐이 있으면 안되는지?
   - 베이스라인, 프로토타입
     - 모델이 더 좋아졌다고 판단할 수 있는 Baseline이 필요
       - 꼭 모델일 필요는 없음
       - 자신이 모델이라 생각하고 어떻게 분류할지 Rule Base 규칙 설계
     - 간단한 모델부터 시작하는 이유
       - 어떻게든 모델의 위험을 낮추는 것이 목표가 되어야 함
       - 가장 좋은 방법은 최악의 성능을 알기 위해 허수아비 모델로 시작하는 것
     - 유사한 문제를 해결하고 있는 SOTA 논문 파악해보기 => 우리의 문제에선 어떤 시도를 해볼 수 있을까?
     - 베이스라인 이후에 간단한 모델을 만들면 피드백을 들어보면 좋음
     - 회사의 동료들에게 모델을 활용할 수 있는 환경 준비
     - 프로토타입을 만들어서 제공
       - Input을 입력하면 Output을 반환하는 웹페이지
       - 이왕이면 좋은 디자인을 가지면 좋지만, 여기선 모델의 동작이 더 중요
       - HTML에 집중하는 것보다, 모델에 집중하는게 중요
       - 이를 위해 Voila, Streamlit, Gradio 등을 활용
   - Metric Evaluation
     - 모델의 성능 지표와 별개로 비즈니스 목표에 영향을 파악하는 것도 중요
     - **앞선 문제를 해결할 경우 어떤 지표가 좋아질까?를 고민해야 함**
     - 이 부분은 작게는 모델의 성능 지표(RMSE)일 수 있고, 크게는 비즈니스의 지표일 수 있음(고객의 재방문율, 매출 등)
     - 지표를 잘 정의해야우리의 Action이 기존보다 더 성과를 냈는지 아닌지를 파악할 수 있음 (이를 위해 AB Test를 진행하기도 함)
     - 만든 모델이 비즈니스에 어떤 임팩트를 미쳤을지(매출 증대에 기여, 내부 구성원들의 시간 효율화 증대 등) 고려하면서 만드는 사람
     - 대부분 기업은 이익 극대화를 목표. 머신러닝 프로젝트는 궁극적으로 수익을 높이는 것이 목표
     - 개발 및 배포 중에 시스템의 성능은 어떻게 판단할 수 있을까?
     - 정답 레이블이 필요한 경우 사용자 반응에서 어떻게 레이블을 추론할 수 있을까?
     - 모델 성능을 비즈니스 Goal과 Objectives를 어떻게 연결할 수 있을까?

   1.6 Action(모델 개발 후 배포 & 모니터링)

   - 앞서 정의한 지표가 어떻게 변하는지 파악하기
     - 현재 만든 모델이 어떤 결과를 내고 있는가?
     - 잘못 예측하고 있다면 어떤 부분이 문제일까?
     - 어떤 부분을 기반으로 예측하고 있을까?
     - Feature의 어떤 값을 사용할 때 특히 잘못 예측하고 있는가?

   1.7 추가 원인 분석

   - 새롭게 발견한 상황을 파악해 어떤 방식으로 문제를 해결할지 모색
   - 그 과정에서 앞서 진행한 과정을 반복

2. 비즈니스 모델

   - 회사에서 일을 할때는 비즈니스 모델을 먼저 파악하는 것이 중요히다.
   - 회사는 비즈니스 모델을 만들고, 비즈니스 모델을 통해 매출이 발생함.
   - 해당 비즈니스 모델에서 어떤 데이터가 존재하고 그 데이터를 기반으로 어떤 것을 만들 수 있을지 생각

   2.1 비즈니스 모델 파악하기

   1. 회사의 비즈니스 파악하기
      - 회사가 어떤 서비스, 가치를 제공하고 있는가?
   2. 데이터를 활용할 수 있는 부분은 어디인가? (Input)
      - 데이터가 존재한다면 어떤 데이터가 존재하는가?
      - 데이터로 무엇을 할 수 있을까?
      - 해당 데이터는 신뢰할만한가? 데이터 정합성은 맞는가? 레이블이 잘 되어있는가? 계속 받을 수 있는가?
      - 다양한 팀에 있는 분들과 직접 인터뷰하는 것도 좋은 방법
      - 무엇을 해볼 수 있을까?
      - 왜 해야하는가?
   3. 모델을 활용한다고 하면 예측의 결과가 어떻게 활용되는가? (Output)
      - 고객에게 바로 노출(추천, 얼굴 필터 등) => 더 좋은 가치 제공 / 매출 증대
      - 내부 인원이 수동으로 진행해야 하는 업무를 자동화할 수 있음

- Special Mission
  - 부스트캠프 AI Tech 혹은 개인 프로젝트를 앞선 방식으로 정리해보기
  - 실제로 회사에서 한 일이 아니더라도, 특정 회사에서 활용했다고 가정하거나 아예 크게 문제 정의해서 구체화해보기
  - 이 모델이 회사에서 활용되었다면 어떤 임팩트를 낼 수 있었을까? 고민해서 정리해보기!
  - 직접 일상의 문제라도 하나씩 정의하기

### (3강) Linux & Shell Command

1. Linux

   1.1 Linux

   1.2 Linux를 알아야 하는 이유

   - 서버에서 자주 사용하는 OS
   - Free, 오픈소스
   - 안정성, 신뢰성. 유닉스라 Stability, Reliability
   - 커맨드, 쉘 스크립트

   1.3 CLI, GUI

   - CLI (Command Line Interface) : Terminal
   - GUI (\- Graphic User Interface) : Desktop

   1.4 대표적인 Linux 배포판

   - Debian
     - 온라인 커뮤니티에서 제작해 배포
   - Ubuntu
     - 영국의 캐노니컬이라는 회사에서 만든 배포판으로 쉽고 편한 설치
     - 초보자들이 쉽게 접근할 수 있도록 만듬
   - Redhat
     - 레드햇이라는 회사에서 배포한 리눅스
   - CentOS
     - Red Hat이 공개한 버전을 가져와서 브랜드와 로고를 제거하고 배포한 버전

   1.5 Linux, Shell Script 학습 가이드

   - 최초엔 **자주 사용하는** 쉘 커맨드, 쉘 스크립트 위주로 학습
   - 필요한 코드가 있는 경우 검색해서 찾기
   - 해당 코드에서 나오는 새로운 커맨드 학습해서 정리하기
   - 왜 이렇게 되는가? 생각하며 배경 지식이 필요한 경우 Linux, OS 학습(아마도 커널)

   1.6 Linux를 사용하는 방법

   - \- VirtualBox에 Linux 설치, Docker로 설치
   - WSL 사용(윈도우)
   - Notebook에서 터미널 실행
   - 2.4 Cloud에서 띄우는 인스턴스에서 연습

2. Shell Command

   2.1 쉘의 종류

   - 쉘
     - 사용자가 문자를 입력해 컴퓨터에 명령할 수 있도록 하는 프로그램
   - 터미널/콘솔
     - 쉘을 실행하기 위해 문자 입력을 받아 컴퓨터에 전달
     - 프로그램의 출력을 화면에 작성
   - sh
     - 최초의 쉘
   - bash
     - Linux 표준 쉘
   - zsh
     - Mac 카탈리나 OS 기본 쉘

   2.2 쉘을 사용하는 경우

   - 서버에서 접속해서 사용하는 경우
   - crontab 등 Linux의 내장 기능을 활용하는 경우
   - 데이터 전처리를 하기 위해 쉘 커맨드를 사용
   - Docker를 사용하는 경우
   - 수백대의 서버를 관리할 경우
   - Jupyter Notebook의 Cell에서 앞에 !를 붙이면 쉘 커맨드가 사용됨
   - 터미널에서 python3, jupyter notebook 도 쉘 커맨드
   - Test Code 실행
   - 배포 파이프라인 실행(Github Action 등에서 실행)

   2.3 기본 쉘 커맨드

   - mam
     - 쉘 커맨드의 매뉴얼 문서를 보고 싶은 경우
     - ex) man python
     - 종료 : \`:q\` 입력
   - mkdir
     - 폴더 생성하기 : Make Directory
     - mkdir linux-test
   - ls
     - 현재 접근한 폴더의 폴더, 파일 확인 : List Segments
     - ls 뒤에 아무것도 작성하지 않으면 현재 폴더 기준으로 실행. 폴더를 작성하면 폴더 기준에서 실행
     - 옵션
     - -a : .으로 시작하는 파일, 폴더를 포함해 전체 파일 출력
     - -l : 퍼미션, 소유자, 만든 날짜, 용량까지 출력
     - -h : 용량을 사람이 읽기 쉽도록 GB, MB 등 표현. \`-l\`과 같이 사용
   - pwd
     - 현재 폴더 경로를 절대 경로로 보여줌 : Print Working Directory
     - pwd
   - cd
     - 폴더 변경하기, 폴더로 이동하기 : Change Directory
     - cd linux-test
   - echo
     - Python의 print처럼 터미널에 텍스트 출력
     - echo "hi"
     - echo \`쉘 커맨드\` 입력시 쉘 커맨드의 결과를 출력. \` : 1 왼쪽에 있는 backtick 
     - echo \`pwd\`
   - vi
     - vim 편집기로 파일 생성
       - INSERT 모드에서만 수정할 수 있음
     - vi vi-test.sh
     - (새로운 창이 뜨면) i 를 눌러서 INSERT 모드로 변경. 그 후 echo “hi” 작성
     - ESC를 누른 후 :wq (저장하고 나가기, write and quit)
     - ESC :wq! : 강제로 저장하고 나오기
     - ESC :q : 그냥 나가기
     - vi 편집기의 Mode
       - Command Mode
         - vi 실행시 기본 Mode
         - 방향키를 통해 커서를 이동할 수 있음
         - dd : 현재 위치한 한 줄 삭제
         - i : INSERT 모드로 변경
         - x : 커서가 위치한 곳의 글자 1개 삭제(5x : 문자 5개 삭제)
         - yy : 현재 줄을 복사(1줄을 ctrl + c)
         - p : 현재 커서가 있는 줄 바로 아래에 붙여넣기
         - k : 커서 위로
         - j : 커서 아래로
         - l : 커서 오른쪽으로
         - h : 커서 왼쪽으로
       - Insert Mode
         - 파일을 수정할 수 있는 Mode
         - 만약 Command Mode로 다시 이동하고 싶다면 ESC 입력
       - Last Line Mode
         - ESC를 누른 후 콜론(:)을 누르면 나오는 Mode
         - w : 현재 파일명으로 저장
         - q : vi 종료(저장되지 않음)
         - q! : vi 강제 종료(!는 강제를 의미)
         - wq : 저장한 후 종료
         - /문자 : 문자 탐색
           - 탐색한 후 n을 누르면 계속 탐색 실행
         - set nu : vi 라인 번호 출력
   - bash
     - bash로 쉘 스크립트 실행
     - bash vi-test.sh
     - 앞에서 작성한 "hi"가 출력
     - 터미널에서 Tab을 누르면 자동완성(지원하지 않는 쉘도 존재)
   - sudo
     - 관리자 권한으로 실행하고 싶은 경우 커맨드 앞에 sudo를 붙임
     - sudo 명령어 : 최고 권한을 가진 슈퍼 유저로 프로그램을 실행
     - "superuser do"에서 유래하고, 최근엔 "substitute user do"(다른 사용자의 권한으로 실행)의 줄임말로 해석
   - cp
     - 파일 또는 폴더 복사하기 : Copy
     - cp vi-test.sh vi-test2.sh
     - -r : 디렉토리를 복사할 때 디렉토리 안에 파일이 있으면 recursive(재귀적)으로 모두 복사
     - -f : 복사할 때 강제로 실행
   - mv
     - 파일, 폴더 이동하기(또는 이름 바꿀 때도 활용) : Move
     - mv vi-test.sh vi-test3.sh
   - cat
     - 특정 파일 내용 출력 : concatenate
     - cat vi-test.sh
     - 여러 파일을 인자로 주면 합쳐서(CONCAT) 출력
       - cat vi-test2.sh vi-test3.sh
     - 파일에 저장하고(OVERWRITE) 싶은 경우
       - cat vi-test2.sh vi-test3.sh > new_test.sh
     - 파일에 추가(APPEND) 싶은 경우
       - cat vi-test2.sh vi-test3.sh >> new_test.sh
   - clear
     - 터미널 창을 깨끗하게 해줌
   - history
     - 최근에 입력한 쉘 커맨드 History 출력
     - History 결과에서 느낌표를 붙이고 숫자 입력시 그 커맨드를 다시 활용할 수 있음
     - !30
   - find
     - 파일 및 디렉토리를 검색할 때 사용
     - 현재 폴더에서 File이란 이름을 가지는 파일 및 디렉토리 검색
       - find . -name "File"
   - export
     - export로 환경 변수 설정
     - export water=”물" (띄어쓰기하면 인지 못함)
     - echo $water
     - export로 환경 변수 설정한 경우, 터미널이 꺼지면 사라지게 됨.
     - 매번 쉘을 실행할 때마다 환경변수를 저장하고 싶으면 .bashrc, .zshrc에 저장하면 됨 
     - (Linux) vi ~/.bashrc 또는 vi ~/.zshrc (자신이 사용하는 쉘에 따라 다름)
     - 제일 하단에 export water=”물"을 저장하고 나옴(ESC :wq)
     - 그 후 source ~/.bashrc 또는 source ~/.zshrc
     - Linux 환경 설정을 재로그인하지 않고 즉시 적용하고 싶은 경우 source 사용
   - alias
     - 터미널에서 alias라고 치면 현재 별칭으로 설정된 것을 볼 수 있음
     - alias는 기본 명령어를 간단히 줄일 수 있는 것
     - 예) ll는 ls -l로 별칭이 지정되어 있음. ll2를 입력하면 ls -l이 동작됨
       - alias ll2='ls -l' 
   - 아래 커맨드는 일상처럼 사용할 수 있도록 연습!
     - mkdir, cd, ls, echo, vi, wget, pwd, mv, cp, clear, history, cat, bash, export, alias
   - head, tail
     - 파일의 앞/뒤 n행 출력
     - head -n 3 vi-test.sh
   - sort
     - 행 단위 정렬
     - -r : 정렬을 내림차순으로 정렬(Default 옵션 : 오름차순)
     - -n : Numeric Sort
     - vi fruits.txt
       - banana
       - orange
       - apple
       - apple
       - orange
       - orange
       - apple
       - banana
     - ESC :wq로 저장
     - cat fruits.txt | sort
     - cat fruits.txt | sort -r
   - uniq
     - 중복된 행이 연속으로 있는 경우 중복 제거.
     - sort와 함께 사용
     - -c : 중복 행의 개수 출력
     - cat fruits.txt | uniq
     - cat fruits.txt | sort | uniq
     - cat fruits.txt | uniq | wc -l
     - cat fruits.txt | sort | uniq | wc -l
   - grep
     - 파일에 주어진 패턴 목록과 매칭되는 라인 검색
     - grep 옵션 패턴 파일명
     - 옵션
       - -i : Insensitively하게, 대소문자 구분 없이 찾기
       - -w : 정확히 그 단어만 찾기
       - -v: 특정 패턴 제외한 결과 출력
       - -E : 정규 표현식 사용
     - 정규 표현식 패턴
       - ^단어 : 단어로 시작하는 것 찾기
       - 단어$ : 단어로 끝나는 것 찾기
       - . : 하나의 문자 매칭
   - cut
     - 파일에서 특정 필드 추출
       - -f : 잘라낼 필드 지정
       - -d : 필드를 구분하는 구분자. Default는 \t
     - vi cut_file
     - root :x:0:0:root:/root:/bin/bash b
     - n:x:1:1:bin:/bin:/sbin/nologin d
     - emon:x:2:2:daemon:/sbin:/sbin/nologin
     - ESC :wq
     - cat cut_file | cut -d : -f 1,7 # 1번째, 7번째 값을 가져옴

   2.4 Redirection & Pipe

   - 표준 스트림(Stream)
     - Unix에서 동작하는 프로그램은 커맨드 실행시 3개의 Stream이 생성
     - stdin : 0으로 표현, 입력(비밀번호, 커맨드 등)
     - stdout : 1로 표현, 출력 값(터미널에 나오는 값)
     - stderr : 2로 표현, 디버깅 정보나 에러 출력

   - Redirection : 프로그램의 출력(stdout)을 다른 파일이나 스트림으로 전달
     - \> : 덮어쓰기(Overwrite) 파일이 없으면 생성하고 저장
     - \>> : 맨 아래에 추가하기(Append)
     - echo "hi" > vi-test3.sh
     - echo "hello" >> vi-test3.sh
     - cat vi-test3.sh
   - Pipe : 프로그램의 출력(stdout)을 다른 프로그램의 입력으로 사용하고 싶은 경우, A의 Output을 B의 Input으로 사용(다양한 커맨드를 조합)
     - 현재 폴더에 있는 파일명 중 vi가 들어간 단어를 찾고 싶은 경우
       - ls | grep "vi"
         - grep "vi" : 특정 단어 찾기
     - 위  결과를 다시 output.txt에 저장하고 싶은 경우
       - ls | grep “vi” > output.txt
     - 최근 입력한 커맨드 중 echo가 들어간 명령어를 찾고 싶은 경우
       - history | grep "echo"

   2.5 서버에서 자주 사용하는 쉘 커맨드

   - ps
     - 현재 실행되고 있는 프로세스 출력하기 : Process Status
     - -e : 모든 프로세스
     - -f : Full Format으로 자세히 보여줌
   - curl
     - Command Line 기반의 Data Transfer 커맨드 : Client URL
     - Request를 테스트할 수 있는 명령어. 웹 서버를 작성한 후 요청이 제대로 실행되는지 확인할 수 있음
     - curl -X localhost:5000/ {data}
     - curl 외에 httpie 등도 있음(더 가독성있게 출력)
   - df
     - 현재 사용 중인 디스크 용량 확인 : Disk Free
     - -h : 사람이 읽기 쉬운 형태로 출력
   - scp
     - SSH을 이용해 네트워크로 연결된 호스트 간 파일을 주고 받는 명령어 : Secure Copy(Remote file copy program)
     - -r : 재귀적으로 복사
     - -P : ssh 포트 지정
     - -i : SSH 설정을 활용해 실행
     - local => remote
       - scp local_path user@ip:remote_directory
     - remote => local
       - scp user@ip:remote_directory local_path
     - remote => remote
     - scp user@ip:remote_directory user2@ip2:target_remote_directory
   - nohup
     - 터미널 종료 후에도 계속 작업이 유지하도록 실행(백그라운드 실행)
     - nohup python3 app.py &
     - nohup으로 실행될 파일은 Permission이 755여야 함
     - 종료는 ps ef | grep app.py 한 후, pid(Process ID) 찾은 후 kill -9 pid 로 프로세스를 Kill
     - 로그는 nohup.out에 저장됨
     - nohup 외에도 screen이란 도구도 있음
   - chmod
     - 파일의 권한을 변경하는 경우 사용 : Change Mode
     - 유닉스에서 파일이나 디렉토리의 시스템 모드를 변경함
     - ls -al(혹은 ll)을 입력하면 다음과 같이 나옴
     - Permission
       - r = Read(읽기), 4
       - w = Write(쓰기), 2
       - x = eXecute(실행하기), 1
       - -= Denied
       - r-x : 읽거나 실행할 수는 있지만 수정은 불가능
       - 755, 644로 퍼미션을 주세요! 라고 하는 경우가 존재
       - rwx를 더하면 4+2+1 = 7
       - chmod 755 vi-test2.sh 를 실행하면 파일의 Permission이 변경됨

   2.6 쉘 스크립트

   - .sh 파일을 생성하고, 그 안에 쉘 커맨드를 추가
   - 파이썬처럼 if, while, case 문이 존재하며 작성시 bash name.sh로 실행 가능
   - 쉘 스크립트 = 쉘 커맨드의 조합
   - 쉘 커맨드에 익숙해진 후, 스크립트로 생성(Python과 유사)
   - 지금은 쉘 커맨드에 많이 익숙해진 후, 추후에 하나씩 만들어보기(쉘 커맨드가 항상 베이스)
     - https://github.com/zzsza/shell-scripts
     - https://github.com/denysdovhan/bash-handbook
     - https://github.com/epety/100-shell-script-examples

- Special Mission
  1. 학습한 쉘 커맨드 정리하기
  2. 카카오톡 그룹 채팅방에서 옵션 - 대화 내보내기로 csv로 저장 후, 쉘 커맨드 1줄로 카카오톡 대화방에서 2021년에 제일 메세지를 많이 보낸 TOP 3명 추출하기!

# 2. 피어세션 정리

- 강의 리뷰 및 QnA
  - (2강) 머신러닝 프로젝트 라이프 사이클
  - (3강) Linux & Shell Command
- 프로그래머스 과제관 - 미술작품 분류하기
  - 분류해보기
  - 모델에 관해 발표해보기 (2.18. 금)

# 3. 회고

- 시간이 여유로울때 pstage를 대비해 분류 모델을 만들어보자!
